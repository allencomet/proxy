proxy_server
------------------------------------
a proxy server code that may help you learn network programming

Copyright 2018 r9wemeet@outlook.com Inc.

https://github.com/allencomet/proxy.git

Overview
--------
这是一个网络编程中经常会遇到的一些问题整合的代码集合，里面涉及到了多线程结合epoll利用ET模式如何实现高效实现网络通信的相关知识，
为了代码能够在一些老的gcc编译器上运行，本源代码使用了boost库去代替一些c++11的功能实现，希望这份源码可以帮助正在学习网络编程的
小伙伴，代码上如有误之处（本猿才疏学浅，知识有限），望客观批评，将错误信息通过r9wemeet@outlook.com发送到本人邮箱，如本人看到定会
及时恢复并纠正。

运行逻辑图：
rpc_client --> proxy --> backend
rpc_client --> proxy
ipc_client --> backend


client与proxy是RPC通信，而proxy是IPC通信，这样就意味着proxy和backend是在同一台机器上
当然client也可以直接和bakcend通信，通过IPC的方式，后续我会增加proxy与backend也是RPC的通信方式

这里的测试用例是client向proxy发出请求，然后proxy根据client的请求通过system调用动态创建了一个backend进程为这个用户的请求服务器，
那么这里可能会有小伙伴有疑问了，现在的服务器模型早就用单进程多线程这种模型取代了多进程的服务器模型，是的，没错，这个是肯定的，
所以我之所以设计这样的类型理由如下：
（1）我是为了体现代理的角色，在这里模拟了一个后端进程，通过后端进程去处理数据，proxy在这里仅仅是一个转发的作用
（2）特殊业务需求，我在公司开发一个项目的过程中遇到了这样的情况，由于我们必须使用对接客户服务器的API，但是客户的API存在缺陷，测试发现
在一个进程内创建的连接数过多会引起程序crash，如果真的发生了这样的crash，按照单进程多线程的模型，在同一个进程内，不论是哪一个线程的崩溃
都会导致整个进程的crash退出，而一个很好的解决方案就是将这些具体处理业务的模块放到独立的一个进程里面去，这样在某个子进程真的crash之后主
进程还能正常接收前端客户请求，将请求分发到其他的后端进程中处理
	以上两个理由好像并不能很好的解释我为什么要通过system去启动一个后端进程，为什么在启动阶段就初始化创建一个进程池去服务器呢，这样肯定
会比动态创建进程效率更高，那么我给出的理由还是说具体情况具体分析：
（1）我开发的backend是可以通过命令行设置入参启动的，所以这样的话我可以根据不同的业务需求以不同方式启动一个后端进程，比如我可以在proxy
中增加一些配置项某个用户去启动不同的进程，甚至可以不是同一套backend

当然，这里的代理服务器以及后端服务器我并没有完善实现所有的功能，后续我会增加一些其他类型的模块：
（1）预创建进程池模块
（2）proxy配置表中配置好后端服务器列表，proxy启动阶段建立与后端服务器的连接池，这样proxy和backend是完全隔离的两套服务器，因为后端服务器
进程的启动方式也是手工启动，这种模型我会加入负载均衡策略



Usage
------------------------------------
```cpp
在bin目录下执行./test -a会启动一个代理服务器和一个客户端进行为期10秒的测试


Note:
------------------------------------
由于程序中捕获了SIG_INT信号，所以如果./proxy -srvip=* -srvport=8080启动后以ctrl+c方式尝试停止程序运行是行不通的，
正确的做法应该是：
（1）找到该服务进程ID：ps -elf | grep proxy 
（2）然后kill pid

#running server
#中途修改代码，现在要爸整体架构做一些调整，仅仅以下方式启动无法运行，后续更新会有说明
[root@localhost bin]# ./proxy -srvip=* -srvport=8080 &;tail -f log/proxy.INFO

#running client
[root@localhost bin]# ./rpc_client 127.0.0.1 8080



What's left for proxy
------------------------------------
后续我会增加一些其他类型的模块：
（1）预创建进程池模块
（2）proxy配置表中配置好后端服务器列表，proxy启动阶段建立与后端服务器的连接池，这样proxy和backend是完全隔离的两套服务器，因为后端服务器
进程的启动方式也是手工启动，这种模型我会加入负载均衡策略
